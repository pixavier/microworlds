<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>JSON → (Nested) Table with Click Events</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .table-wrap { overflow: auto; max-width: 100%; }

    .json-table {
      border-collapse: collapse;
      table-layout: auto;           /* auto size columns by content */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-size: 12px;
    }
    .json-table.fit-fill { width: 100%; }
    .json-table.fit-content { width: auto; }
    @supports (width: max-content) {
      .json-table.fit-content { width: max-content; min-width: 10%; }
    }

    .json-table.title { font-size: 16px; background: #fafbfc; }

    .json-table thead th {
      background: #f6f7f8;
      font-weight: 600;
      text-align: left;
      border: 1px solid #e2e5e9;
      padding: 6px;
      white-space: nowrap;
    }
    .json-table td {
      border: 1px solid #e2e5e9;
      padding: 6px;
      vertical-align: top;
    }
    /* Show CR/LF and wrap long tokens */
    .json-table td.multiline { white-space: pre-line; overflow-wrap: anywhere; }

    /* Nested tables: a bit smaller and inset */
    .json-table.nested { font-size: 12px; background: #fafbfc; }
    .json-table.nested thead th { background: #f0f2f4; }
    .json-table td > .json-table { margin: 4px; }
    .json-table small.muted { color: #6b7280; }

    /* Click UX */
    .json-table td.clickable { cursor: pointer; }
    .json-table td.selected { outline: 2px solid #2563eb; outline-offset: -2px; }
  </style>
</head>
<body>
  <span class="json-table">Basic Data Viewer</span>
  <script src="./libs/JSON5.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  <script>
    // ---------- Demo ----------
    let data = [];

    // ---------- Helpers ----------
    function pmessage(data) {
      let res = '';
      let json = JSON5.parse(data);
      let op = json.op;
      let param = json.param;

      if (op === 'jsonview') addJsonTable(param.json, param.name, param.title);
      if (op === 'highlight') highlightCellByPath(param.path, param.rowIndexPath, param.name);
      if (op === 'chartview') addChart(param.json, param.name, param.title);

      return res;
    }

    const isPlainObject = (o) => o !== null && typeof o === 'object' && !Array.isArray(o);
    const setEq = (a, b) => a.size === b.size && [...a].every(k => b.has(k));
    const isNestedTable = (val) => Array.isArray(val) && val.length > 0 && val.every(isPlainObject);
    const getExpectedColumns = (arr, provided) => provided ?? Object.keys(arr[0] ?? {});
    let __tableSeq = 0;

    function createEmptyTable() {
      const t = document.createElement('table');
      t.className = 'json-table nested';
      const tb = document.createElement('tbody');
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.innerHTML = '<small class="muted">(empty)</small>';
      tr.appendChild(td);
      tb.appendChild(tr);
      t.appendChild(tb);
      return t;
    }

    // ---------- Core (recursive) builder ----------
    // rowPath carries the nested row indices from root → current table
    function buildTable(data, columns = null, level = 0, opts = {}, path = [], rowPath = []) {
      const {
        normalizeEscapedNewlines = false,
        fit = 'content',                  // 'content' | 'fill'
        clickableCells = true,
        highlightOnClick = false,
      } = opts;

      if (!Array.isArray(data)) throw new Error('Data must be an array of objects');
      if (data.length === 0) return createEmptyTable();
      if (!data.every(isPlainObject)) throw new Error('Each item must be a plain object');

      const expectedCols = getExpectedColumns(data, columns);
      const expectedSet = new Set(expectedCols);

      if (columns) {
        const firstSet = new Set(Object.keys(data[0]));
        if (!setEq(firstSet, expectedSet)) {
          throw new Error('Provided columns must match the set of attributes in the data');
        }
      }

      data.forEach((row, idx) => {
        const rowSet = new Set(Object.keys(row));
        if (!setEq(rowSet, expectedSet)) {
          const missing = [...expectedSet].filter(k => !rowSet.has(k));
          const extra = [...rowSet].filter(k => !expectedSet.has(k));
          const parts = [];
          if (missing.length) parts.push(`missing: ${missing.join(', ')}`);
          if (extra.length) parts.push(`extra: ${extra.join(', ')}`);
          throw new Error(`Row ${idx} does not match expected attributes (${[...expectedSet].join(', ')}); ${parts.join(' | ')}`);
        }
      });

      const table = document.createElement('table');
      const tableId = `t${++__tableSeq}`;
      table.dataset.tableId = tableId;
      table.className = 'json-table' + (level > 0 ? ' nested' : '') + (fit === 'fill' ? ' fit-fill' : ' fit-content');

      // THEAD
      const thead = document.createElement('thead');
      const trHead = document.createElement('tr');
      expectedCols.forEach((key) => {
        const th = document.createElement('th');
        th.textContent = key;
        trHead.appendChild(th);
      });
      thead.appendChild(trHead);
      table.appendChild(thead);

      // TBODY
      const tbody = document.createElement('tbody');
      data.forEach((row, rowIndex) => {
        const tr = document.createElement('tr');
        const currentRowPath = [...rowPath, rowIndex]; // accumulate indices

        expectedCols.forEach((colKey) => {
          const td = document.createElement('td');
          let val = row[colKey];

          // Path including THIS cell's attr
          const pathWithAttr = [...path, colKey];

          // Attach metadata for click handling
          td.dataset.cell = "1";
          td.dataset.tableId = tableId;
          td.dataset.level = String(level);
          td.dataset.rowIndex = String(rowIndex);
          td.dataset.colKey = colKey;
          td.dataset.path = JSON.stringify(pathWithAttr);             // include attr at end
          td.dataset.rowIndexPath = JSON.stringify(currentRowPath);   // full row indices from root
          if (clickableCells) td.classList.add('clickable');

          // Store rich info directly on the node (avoids heavy data-* attrs)
          td.__cellInfo = {
            tableId,
            level,
            path: pathWithAttr,             // include attr
            rowIndex,                       // index at this level
            rowIndexPath: currentRowPath,   // full nested row path
            colKey,
            value: val,
            row,
            columns: [...expectedCols],
            highlightOnClick
          };

          if (isNestedTable(val)) {
            // Recurse into nested array of objects (table path extends by the key)
            const nested = buildTable(
              val,
              null,
              level + 1,
              opts,
              [...path, colKey],
              currentRowPath
            );
            td.appendChild(nested);
          } else if (Array.isArray(val)) {
            const allPrimitive = val.every(v => v === null || (typeof v !== 'object'));
            let s = allPrimitive ? val.join(', ') : JSON.stringify(val);
            if (normalizeEscapedNewlines) s = s.replace(/\\r\\n/g, '\r\n').replace(/\\n/g, '\n').replace(/\\r/g, '\r');
            td.textContent = s;
            td.classList.add('multiline');
            td.__cellInfo.value = s;
          } else if (typeof val === 'string') {
            if (normalizeEscapedNewlines) val = val.replace(/\\r\\n/g, '\r\n').replace(/\\n/g, '\n').replace(/\\r/g, '\r');
            td.textContent = val;
            td.classList.add('multiline');
            td.__cellInfo.value = val;
          } else if (isPlainObject(val) && Object.keys(val).length > 0) {
            let s = JSON.stringify(val);
            if (normalizeEscapedNewlines) s = s.replace(/\\r\\n/g, '\r\n').replace(/\\n/g, '\n').replace(/\\r/g, '\r');
            td.textContent = s;
            td.classList.add('multiline');
            td.__cellInfo.value = s;
          } else if (val === null || val === undefined) {
            td.textContent = '';
            td.__cellInfo.value = null;
          } else {
            td.textContent = String(val);
            td.__cellInfo.value = String(val);
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      return table;
    }

    // ---------- Public API with click delegation ----------
    function renderJsonTable(name, title, data, columns = null, options = {}) {

	  let el = document.createElement('div');
	  el.id = name;
	  document.body.appendChild(el);

      // Default noop handler
      const onCellClick = typeof options.onCellClick === 'function'
        ? options.onCellClick
        : (info) => { console.log('Cell clicked:', info); };

      // Render
      el.innerHTML = `<br><span class="json-table title">${title}</span><span class="json-table" style="color:white"> (id=${name})</span>`;
      el.appendChild(buildTable(data, columns, 0, options, [], [])); // start with empty rowPath

      // Delegate click handling (attach once per mount element)
      if (!el.__jsonTable_clickBound) {
        el.addEventListener('click', (event) => {
          const td = event.target.closest('td[data-cell="1"]');
          if (!td || !el.contains(td)) return;

          const info = td.__cellInfo || null;
          const handler = el.__jsonTable_onCellClick;
          if (info && info.highlightOnClick) {
            td.classList.toggle('selected');
            setTimeout(function(){td.classList.remove('selected');}, 750);
          }
          if (typeof handler === 'function') {
            handler({ ...info, event });
          }
        });
        el.__jsonTable_clickBound = true;
      }
      // Update handler reference for this render
      el.__jsonTable_onCellClick = onCellClick;
    }

    function addJsonTable(data, name, title) {
	
	  if (document.getElementById(name)) {
		 return false;
	  }
	
      renderJsonTable(name, title, data, null, {
        normalizeEscapedNewlines: true,
        fit: 'content',
        clickableCells: true,
        highlightOnClick: true,
        onCellClick: (info) => {
          // info.path already includes the clicked attr as last element
          console.log('Clicked cell:', {
            attr: info.colKey,
            val: info.value,
            path: info.path,                 // e.g., ["orders","items"]
            rowIndex: info.rowIndex,         // index at this table level
            rowIndexPath: info.rowIndexPath  // e.g., [0,1,2] from root
          });

          if (window.opener) {
            let evt = 'jsonclick';
            let datum = JSON.stringify({
              attr: info.colKey,
              val: info.value,
              path: info.path,
              rowIndexPath: info.rowIndexPath
            });
            window.opener.ide && window.opener.ide.broadcast && window.opener.ide.broadcast(evt, null, datum);
          }
        }
      });
	  
	  return true;
    }

    // Highlight a cell border by path + rowIndexPath
    // - path: array of keys ending with the attr (e.g. ["orders","items","price"])
    // - rowIndexPath: array of row indices from root (e.g. [0,0,1])
    function highlightCellByPath(path, rowIndexPath, name, options = {}) {
      const {
        className = 'selected',  // CSS class to apply
        duration = 0,            // ms to keep the highlight; 0 = keep it on
        scroll = true,           // auto-scroll into view
        toggle = true,           // if already selected, remove it (toggle)
        solo = false             // when selecting, clear the class from other cells first
      } = options;

      const elSel = '#' + name;
      const el = typeof elSel === 'string' ? document.querySelector(elSel) : elSel;
      if (!el) throw new Error('Mount element not found');

      const sPath = Array.isArray(path) ? JSON.stringify(path) : String(path);
      const sIdx  = Array.isArray(rowIndexPath) ? JSON.stringify(rowIndexPath) : String(rowIndexPath);

      const td = Array.from(el.querySelectorAll('td[data-cell="1"]'))
        .find(cell => cell.dataset.path === sPath && cell.dataset.rowIndexPath === sIdx);

      if (!td) return false;

      const isSelected = td.classList.contains(className);

      // TOGGLE: if already selected, remove and stop here
      if (toggle && isSelected) {
        td.classList.remove(className);
        return true;
      }

      // SOLO: clear other selections first
      if (solo) {
        el.querySelectorAll(`td.${className}`).forEach(c => c.classList.remove(className));
      }

      if (scroll && td.scrollIntoView) {
        td.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'nearest' });
      }

      td.classList.add(className);

      if (duration > 0) {
        setTimeout(() => {
          if (td.classList.contains(className)) td.classList.remove(className);
        }, duration);
      }

      return true;
    }


    function addChart(data, name, title) {
	
	  if (document.getElementById(name)) {
		 return false;
	  }
	  
	  document.body.appendChild(document.createElement('br'));

  	  let el = document.createElement('div');
	  el.id = name;
	  document.body.appendChild(el);
/*
	  [
			{
			  name:"labels",
			  data: [1,2,3,4,5,6]
			},  
			{
			  name:"Serie A",
			  data: [1,2,3,4,5,6]
			}  
	  ]
*/
	  let labels = data.find(item => item.name === "labels")?.data;
	  let series = data.filter(item => item.name !== "labels");

	  console.log(series);

	  const options = {
		  chart: { type: 'line', width: 500, height: 300, toolbar: { show: true } },
		  series: series,
		  xaxis: { categories: labels },
		  title: { text: title, style: {fontSize: '12px', fontWeight: '600'} }
	  };

	  new ApexCharts(document.querySelector('#' + name), options).render();
	  return true;
    }


    // -------- Demo data ----------
    let data_json5 =
    [
      {
        id: 1,
        name: "Alice",
        notes: "First line\r\nSecond line (CRLF)\nThird line (LF)",
        orders: [
          { orderId: "A-100", total: 42.5, items: [
            { sku: "X1", qty: 2, price: 10 },
            { sku: "Y3", qty: 1, price: 22.5 }
          ]},
          { orderId: "A-101", total: 15, items: [
            { sku: "Z9", qty: 3, price: 5 }
          ]}
        ]
      },
      {
        id: 2,
        name: "Bob",
        notes: "row1\\r\\nrow2 (escaped in source)\\nrow3",
        orders: [
          { orderId: "B-200", total: 8, items: [
            { sku: "X1", qty: 1, price: 8 }
          ]}
        ]
      }
    ];

    let data_json =
    [
      {
        "id": 1,
        "name": "Alice",
        "notes": "First line\r\nSecond line (CRLF)\nThird line (LF)",
        "orders": [
          { "orderId": "A-100", "total": 42.5, "items": [
            { "sku": "X1", "qty": 2, "price": 10 },
            { "sku": "Y3", "qty": 1, "price": 22.5 }
          ]},
          { "orderId": "A-101", "total": 15, "items": [
            { "sku": "Z9", "qty": 3, "price": 5 }
          ]}
        ]
      },
      {
        "id": 2,
        "name": "Bob",
        "notes": "row1\\r\\nrow2 (escaped in source)\\nrow3",
        "orders": [
          { "orderId": "B-200", "total": 8, "items": [
            { "sku": "X1", "qty": 1, "price": 8 }
          ]}
        ]
      }
    ];

  </script>
</body>
</html>
